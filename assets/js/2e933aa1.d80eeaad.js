"use strict";(self.webpackChunkmy_docusaurus_site=self.webpackChunkmy_docusaurus_site||[]).push([[4706],{6810:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>l,default:()=>h,frontMatter:()=>d,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"guide/OOP/Dunder_Methods/README","title":"Utilizing Dunder Methods in Classes","description":"In this tutorial, we will explore the concept of dunder methods, also known as magic methods, and their application in Python classes. Dunder methods, short for \\"double underscore\\" methods, are special methods with double leading and trailing underscores (e.g., init). These methods are integral to defining the behavior of objects in Python. While we\'ve already encountered the init method for initializing instances, we will delve deeper into other dunder methods that enhance the functionality and interactivity of our classes.","source":"@site/docs/guide/07_OOP/06_Dunder_Methods/README.md","sourceDirName":"guide/07_OOP/06_Dunder_Methods","slug":"/guide/OOP/Dunder_Methods/","permalink":"/Python/docs/guide/OOP/Dunder_Methods/","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/guide/07_OOP/06_Dunder_Methods/README.md","tags":[],"version":"current","frontMatter":{},"sidebar":"guideSidebar","previous":{"title":"Understanding Class and Instance Attributes in Python","permalink":"/Python/docs/guide/OOP/Attributes_Class_and_Instance/"},"next":{"title":"Comprehensive Tutorial on str() and repr() in Python","permalink":"/Python/docs/guide/OOP/str()_repr()/"}}');var o=t(4848),s=t(8453);const d={},l="Utilizing Dunder Methods in Classes",r={},a=[{value:"Introduction to Dunder Methods",id:"introduction-to-dunder-methods",level:2},{value:"Example Class: Book",id:"example-class-book",level:2},{value:"Step 1: Defining the <code>__init__</code> Method",id:"step-1-defining-the-__init__-method",level:2},{value:"Step 2: Implementing the <code>__len__</code> Method",id:"step-2-implementing-the-__len__-method",level:2},{value:"Step 3: Testing the <code>__len__</code> Method",id:"step-3-testing-the-__len__-method",level:2},{value:"Step 4: Implementing the <code>__add__</code> Method",id:"step-4-implementing-the-__add__-method",level:2},{value:"Step 5: Testing the <code>__add__</code> Method",id:"step-5-testing-the-__add__-method",level:2},{value:"Full Implementation",id:"full-implementation",level:2},{value:"Conclusion",id:"conclusion",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"utilizing-dunder-methods-in-classes",children:"Utilizing Dunder Methods in Classes"})}),"\n",(0,o.jsxs)(n.p,{children:['In this tutorial, we will explore the concept of dunder methods, also known as magic methods, and their application in Python classes. Dunder methods, short for "double underscore" methods, are special methods with double leading and trailing underscores (e.g., ',(0,o.jsx)(n.code,{children:"__init__"}),"). These methods are integral to defining the behavior of objects in Python. While we've already encountered the ",(0,o.jsx)(n.code,{children:"__init__"})," method for initializing instances, we will delve deeper into other dunder methods that enhance the functionality and interactivity of our classes."]}),"\n",(0,o.jsx)(n.h2,{id:"introduction-to-dunder-methods",children:"Introduction to Dunder Methods"}),"\n",(0,o.jsx)(n.p,{children:"Dunder methods enable customization of fundamental object behaviors, such as initialization, representation, arithmetic operations, and more. It's crucial to note that these methods are not called directly by their names. Instead, they are invoked implicitly through specific syntax or functions in Python."}),"\n",(0,o.jsx)(n.h2,{id:"example-class-book",children:"Example Class: Book"}),"\n",(0,o.jsxs)(n.p,{children:["To demonstrate the use of dunder methods, we'll define a ",(0,o.jsx)(n.code,{children:"Book"})," class. This class will include several dunder methods to illustrate their functionalities."]}),"\n",(0,o.jsxs)(n.h2,{id:"step-1-defining-the-__init__-method",children:["Step 1: Defining the ",(0,o.jsx)(n.code,{children:"__init__"})," Method"]}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"__init__"})," method initializes class instances. Here, we'll define a ",(0,o.jsx)(n.code,{children:"Book"})," class with attributes for the title and number of pages."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"class Book:\n    def __init__(self, title: str, pages: int) -> None:\n        self.title = title\n        self.pages = pages\n"})}),"\n",(0,o.jsxs)(n.h2,{id:"step-2-implementing-the-__len__-method",children:["Step 2: Implementing the ",(0,o.jsx)(n.code,{children:"__len__"})," Method"]}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"__len__"})," method allows the use of the ",(0,o.jsx)(n.code,{children:"len()"})," function on instances of the class. In our ",(0,o.jsx)(n.code,{children:"Book"})," class, it will return the number of pages."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"    def __len__(self) -> int:\n        return self.pages\n"})}),"\n",(0,o.jsxs)(n.h2,{id:"step-3-testing-the-__len__-method",children:["Step 3: Testing the ",(0,o.jsx)(n.code,{children:"__len__"})," Method"]}),"\n",(0,o.jsxs)(n.p,{children:["We can test our ",(0,o.jsx)(n.code,{children:"__len__"})," method by creating instances of the ",(0,o.jsx)(n.code,{children:"Book"})," class and using the ",(0,o.jsx)(n.code,{children:"len()"})," function."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'if __name__ == "__main__":\n    pi_daily = Book("Pi Daily", 100)\n    harry_potter = Book("Harry Potter", 340)\n\n    print(len(pi_daily))  # Output: 100\n    print(len(harry_potter))  # Output: 340\n'})}),"\n",(0,o.jsxs)(n.h2,{id:"step-4-implementing-the-__add__-method",children:["Step 4: Implementing the ",(0,o.jsx)(n.code,{children:"__add__"})," Method"]}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"__add__"})," method allows us to use the ",(0,o.jsx)(n.code,{children:"+"})," operator to add instances of the class. In our ",(0,o.jsx)(n.code,{children:"Book"})," class, it will combine the titles and sum the pages of two books."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"    def __add__(self, other: 'Book') -> 'Book':\n        combined_title = f\"{self.title} and {other.title}\"\n        combined_pages = self.pages + other.pages\n        return Book(combined_title, combined_pages)\n"})}),"\n",(0,o.jsxs)(n.h2,{id:"step-5-testing-the-__add__-method",children:["Step 5: Testing the ",(0,o.jsx)(n.code,{children:"__add__"})," Method"]}),"\n",(0,o.jsxs)(n.p,{children:["We can test our ",(0,o.jsx)(n.code,{children:"__add__"})," method by creating instances of the ",(0,o.jsx)(n.code,{children:"Book"})," class and using the ",(0,o.jsx)(n.code,{children:"+"})," operator."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'if __name__ == "__main__":\n    combined_books = pi_daily + harry_potter\n    print(combined_books.title)  # Output: Pi Daily and Harry Potter\n    print(combined_books.pages)  # Output: 440\n'})}),"\n",(0,o.jsx)(n.h2,{id:"full-implementation",children:"Full Implementation"}),"\n",(0,o.jsxs)(n.p,{children:["Below is the full implementation of our ",(0,o.jsx)(n.code,{children:"Book"})," class with the ",(0,o.jsx)(n.code,{children:"__init__"}),", ",(0,o.jsx)(n.code,{children:"__len__"}),", and ",(0,o.jsx)(n.code,{children:"__add__"})," methods:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'class Book:\n    def __init__(self, title: str, pages: int) -> None:\n        self.title = title\n        self.pages = pages\n\n    def __len__(self) -> int:\n        return self.pages\n\n    def __add__(self, other: \'Book\') -> \'Book\':\n        combined_title = f"{self.title} and {other.title}"\n        combined_pages = self.pages + other.pages\n        return Book(combined_title, combined_pages)\n\nif __name__ == "__main__":\n    pi_daily = Book("Pi Daily", 100)\n    harry_potter = Book("Harry Potter", 340)\n\n    print(len(pi_daily))  # Output: 100\n    print(len(harry_potter))  # Output: 340\n\n    combined_books = pi_daily + harry_potter\n    print(combined_books.title)  # Output: Pi Daily and Harry Potter\n    print(combined_books.pages)  # Output: 440\n'})}),"\n",(0,o.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,o.jsxs)(n.p,{children:["Dunder methods are powerful tools in Python that allow developers to customize and extend the behavior of classes. By implementing methods such as ",(0,o.jsx)(n.code,{children:"__init__"}),", ",(0,o.jsx)(n.code,{children:"__len__"}),", and ",(0,o.jsx)(n.code,{children:"__add__"}),", we can create more intuitive and functional objects. Understanding and utilizing these methods effectively can greatly enhance the design and usability of your classes."]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>d,x:()=>l});var i=t(6540);const o={},s=i.createContext(o);function d(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:d(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);