"use strict";(self.webpackChunkpython=self.webpackChunkpython||[]).push([[299],{5365:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"python-guide/Errors/Else_Finally","title":"Exception Handling","description":"In the previous lesson, we delved into the basics of exception handling in Python, primarily utilizing the try and except blocks. However, Python provides additional constructs to enhance error handling capabilities: else and finally blocks. In this tutorial, we\'ll explore these blocks in detail with practical examples.","source":"@site/docs/python-guide/04_Errors/03_Else_Finally.md","sourceDirName":"python-guide/04_Errors","slug":"/python-guide/Errors/Else_Finally","permalink":"/Python/docs/python-guide/Errors/Else_Finally","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/python-guide/04_Errors/03_Else_Finally.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{},"sidebar":"guideSidebar","previous":{"title":"Handling Exceptions","permalink":"/Python/docs/python-guide/Errors/Try_Except"},"next":{"title":"Manually Raising Exceptions","permalink":"/Python/docs/python-guide/Errors/Raise"}}');var t=i(4848),l=i(8453);const o={},r="Exception Handling",c={},a=[{value:"The <code>else</code> Block",id:"the-else-block",level:2},{value:"Syntax:",id:"syntax",level:2},{value:"The <code>finally</code> Block",id:"the-finally-block",level:2},{value:"Syntax:",id:"syntax-1",level:2},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,l.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"exception-handling",children:"Exception Handling"})}),"\n",(0,t.jsxs)(n.p,{children:["In the previous lesson, we delved into the basics of exception handling in Python, primarily utilizing the ",(0,t.jsx)(n.code,{children:"try"})," and ",(0,t.jsx)(n.code,{children:"except"})," blocks. However, Python provides additional constructs to enhance error handling capabilities: ",(0,t.jsx)(n.code,{children:"else"})," and ",(0,t.jsx)(n.code,{children:"finally"})," blocks. In this tutorial, we'll explore these blocks in detail with practical examples."]}),"\n",(0,t.jsxs)(n.h2,{id:"the-else-block",children:["The ",(0,t.jsx)(n.code,{children:"else"})," Block"]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"else"})," block in Python's exception handling mechanism acts as a success listener. It executes only if the code within the ",(0,t.jsx)(n.code,{children:"try"})," block completes successfully without raising any exceptions. It provides a way to distinguish between the normal execution flow and the exceptional cases."]}),"\n",(0,t.jsx)(n.h2,{id:"syntax",children:"Syntax:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"try:\n    # Code that may raise an exception\nexcept ExceptionType:\n    # Exception handling code\nelse:\n    # Code to execute if no exceptions occur\n"})}),"\n",(0,t.jsx)(n.p,{children:"Let's understand its usage with an example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'user_input = "10"  # Hard-coded user input\n\ntry:\n    result = 1 / float(user_input)  # Attempting a potentially risky operation\n    print("1 divided by user input is:", result)\nexcept ValueError:\n    print("You cannot use user input as a value.")\nelse:\n    print("Success! No exceptions encountered.")\n'})}),"\n",(0,t.jsx)(n.p,{children:"In this example:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["If ",(0,t.jsx)(n.code,{children:"user_input"}),' is a non-numeric value like "ABC", the ',(0,t.jsx)(n.code,{children:"except"})," block will handle the ",(0,t.jsx)(n.code,{children:"ValueError"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["If ",(0,t.jsx)(n.code,{children:"user_input"}),' is "0", a ',(0,t.jsx)(n.code,{children:"ZeroDivisionError"})," will be caught by the ",(0,t.jsx)(n.code,{children:"except"})," block."]}),"\n",(0,t.jsxs)(n.li,{children:["If ",(0,t.jsx)(n.code,{children:"user_input"}),' is a valid numeric value like "10", the division operation will succeed, and the ',(0,t.jsx)(n.code,{children:"else"})," block will execute."]}),"\n"]}),"\n",(0,t.jsxs)(n.h2,{id:"the-finally-block",children:["The ",(0,t.jsx)(n.code,{children:"finally"})," Block"]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"finally"})," block ensures that certain code executes, regardless of whether an exception occurs or not. It's typically used for cleanup operations like closing files or releasing resources, ensuring that essential tasks are performed before the program exits."]}),"\n",(0,t.jsx)(n.h2,{id:"syntax-1",children:"Syntax:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"try:\n    # Code that may raise an exception\nexcept ExceptionType:\n    # Exception handling code\nfinally:\n    # Code that always executes, regardless of exceptions\n"})}),"\n",(0,t.jsx)(n.p,{children:"Let's see how it works in practice:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'user_input = "10"  # Hard-coded user input\n\ntry:\n    result = 1 / float(user_input)  # Attempting a potentially risky operation\n    print("1 divided by user input is:", result)\nexcept ValueError:\n    print("You cannot use user input as a value.")\nelse:\n    print("Success! No exceptions encountered.")\nfinally:\n    print("Finally block always executes.")\n'})}),"\n",(0,t.jsx)(n.p,{children:"Here:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Whether the operation succeeds or fails, the ",(0,t.jsx)(n.code,{children:"finally"})," block ensures execution."]}),"\n",(0,t.jsxs)(n.li,{children:["Even if an exception is raised and caught, the ",(0,t.jsx)(n.code,{children:"finally"})," block runs, providing a way to guarantee essential operations are performed before exiting the program."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,t.jsxs)(n.p,{children:["In Python, utilizing ",(0,t.jsx)(n.code,{children:"else"})," and ",(0,t.jsx)(n.code,{children:"finally"})," blocks provides additional control and robustness to your exception handling strategy. While ",(0,t.jsx)(n.code,{children:"else"})," offers a way to distinguish between successful and exceptional executions, ",(0,t.jsx)(n.code,{children:"finally"})," ensures that critical cleanup tasks are performed, regardless of the program's flow. Remember, while these constructs are powerful, it's crucial to use them judiciously and maintain code readability for better maintainability and understanding."]})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>r});var s=i(6540);const t={},l=s.createContext(t);function o(e){const n=s.useContext(l);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),s.createElement(l.Provider,{value:n},e.children)}}}]);