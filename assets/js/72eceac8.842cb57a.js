"use strict";(self.webpackChunkpython=self.webpackChunkpython||[]).push([[1875],{3537:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>r});const t=JSON.parse('{"id":"tips-and-tricks/wtf-is-self","title":"self","description":"Introduction","source":"@site/docs/tips-and-tricks/wtf-is-self.md","sourceDirName":"tips-and-tricks","slug":"/tips-and-tricks/wtf-is-self","permalink":"/Python/docs/tips-and-tricks/wtf-is-self","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/tips-and-tricks/wtf-is-self.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tipsAndTricksSidebar","previous":{"title":"7 Coding Habits of Top 1% Programmers","permalink":"/Python/docs/tips-and-tricks/seven-code-habbits"},"next":{"title":"yield from","permalink":"/Python/docs/tips-and-tricks/yield"}}');var i=s(4848),l=s(8453);const o={},c="self",d={},r=[{value:"Introduction",id:"introduction",level:2},{value:"The Concept of Object-Oriented Programming in Python",id:"the-concept-of-object-oriented-programming-in-python",level:2},{value:"The Role of <code>self</code> in Python",id:"the-role-of-self-in-python",level:3},{value:"Instantiating Objects and the Role of <code>self</code>",id:"instantiating-objects-and-the-role-of-self",level:3},{value:"Detailed Exploration of <code>self</code>",id:"detailed-exploration-of-self",level:2},{value:"How <code>self</code> Enables Instance-Specific Data",id:"how-self-enables-instance-specific-data",level:3},{value:"<code>self</code> in Instance Methods",id:"self-in-instance-methods",level:3},{value:"The Naming Convention of <code>self</code>",id:"the-naming-convention-of-self",level:3},{value:"Self is Implicitly Passed",id:"self-is-implicitly-passed",level:3},{value:"Self in Constructors and Other Special Methods",id:"self-in-constructors-and-other-special-methods",level:3},{value:"Advanced Topics Related to <code>self</code>",id:"advanced-topics-related-to-self",level:2},{value:"Class Methods vs. Instance Methods",id:"class-methods-vs-instance-methods",level:3},{value:"Static Methods: When <code>self</code> Is Not Needed",id:"static-methods-when-self-is-not-needed",level:3},{value:"Self in Inheritance and Method Resolution Order (MRO)",id:"self-in-inheritance-and-method-resolution-order-mro",level:3},{value:"Summary",id:"summary",level:2},{value:"Key Points to Remember",id:"key-points-to-remember",level:3},{value:"Conclusion",id:"conclusion",level:3}];function a(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"self",children:(0,i.jsx)(n.code,{children:"self"})})}),"\n",(0,i.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"self"})," parameter in Python is a cornerstone of object-oriented programming (OOP) within the language. It is essential for creating and managing objects (instances) in a way that encapsulates data and behavior within classes. This guide provides a comprehensive and detailed exploration of what ",(0,i.jsx)(n.code,{children:"self"})," is, how it functions, and why it is critical to the design of Python classes. We will also address common misconceptions and explain advanced topics like method resolution, class methods, and static methods."]}),"\n",(0,i.jsx)(n.h2,{id:"the-concept-of-object-oriented-programming-in-python",children:"The Concept of Object-Oriented Programming in Python"}),"\n",(0,i.jsxs)(n.p,{children:["Before diving into ",(0,i.jsx)(n.code,{children:"self"}),', it\'s important to understand the broader context of object-oriented programming in Python. OOP is a programming paradigm centered around the concept of "objects," which are instances of classes. A class can be thought of as a blueprint that defines a set of properties (attributes) and behaviors (methods) that the objects created from the class will have.']}),"\n",(0,i.jsxs)(n.h3,{id:"the-role-of-self-in-python",children:["The Role of ",(0,i.jsx)(n.code,{children:"self"})," in Python"]}),"\n",(0,i.jsxs)(n.p,{children:["In Python, when you define methods in a class, the first parameter of each method (including the ",(0,i.jsx)(n.code,{children:"__init__"})," constructor) is typically ",(0,i.jsx)(n.code,{children:"self"}),". This parameter is not a keyword but a naming convention used to refer to the instance of the class that is currently being manipulated. It allows each method to access the attributes and other methods of the object it belongs to."]}),"\n",(0,i.jsx)(n.p,{children:"Consider the following class definition:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"class Car:\n    def __init__(self, brand: str, fuel_type: str) -> None:\n        self.brand = brand\n        self.fuel_type = fuel_type\n"})}),"\n",(0,i.jsx)(n.p,{children:"Here:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"self"})," in the ",(0,i.jsx)(n.code,{children:"__init__"})," method represents the instance of the class that is being created."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"self.brand"})," and ",(0,i.jsx)(n.code,{children:"self.fuel_type"})," are attributes that will store the brand and fuel type of the car."]}),"\n"]}),"\n",(0,i.jsxs)(n.h3,{id:"instantiating-objects-and-the-role-of-self",children:["Instantiating Objects and the Role of ",(0,i.jsx)(n.code,{children:"self"})]}),"\n",(0,i.jsxs)(n.p,{children:["When you create an instance of a class, the ",(0,i.jsx)(n.code,{children:"__init__"})," method is automatically invoked, and ",(0,i.jsx)(n.code,{children:"self"})," is implicitly passed by Python to refer to the new instance being created:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'volvo = Car("Volvo", "Diesel")\n'})}),"\n",(0,i.jsx)(n.p,{children:"In this case:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"volvo"})," is an instance of the ",(0,i.jsx)(n.code,{children:"Car"})," class."]}),"\n",(0,i.jsxs)(n.li,{children:["Inside the ",(0,i.jsx)(n.code,{children:"__init__"})," method, ",(0,i.jsx)(n.code,{children:"self.brand"})," is set to ",(0,i.jsx)(n.code,{children:'"Volvo"'}),", and ",(0,i.jsx)(n.code,{children:"self.fuel_type"})," is set to ",(0,i.jsx)(n.code,{children:'"Diesel"'})," for this specific instance."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Each time a new instance is created, ",(0,i.jsx)(n.code,{children:"self"})," allows the instance to have its own unique data."]}),"\n",(0,i.jsxs)(n.h2,{id:"detailed-exploration-of-self",children:["Detailed Exploration of ",(0,i.jsx)(n.code,{children:"self"})]}),"\n",(0,i.jsxs)(n.h3,{id:"how-self-enables-instance-specific-data",children:["How ",(0,i.jsx)(n.code,{children:"self"})," Enables Instance-Specific Data"]}),"\n",(0,i.jsxs)(n.p,{children:["One of the primary purposes of ",(0,i.jsx)(n.code,{children:"self"})," is to enable each instance of a class to maintain its own data. This is crucial because, in OOP, we often need multiple objects of the same class, each with different states."]}),"\n",(0,i.jsx)(n.p,{children:"For example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'bmw = Car("BMW", "Electric")\n'})}),"\n",(0,i.jsxs)(n.p,{children:["Now, ",(0,i.jsx)(n.code,{children:"bmw"})," is another instance of the ",(0,i.jsx)(n.code,{children:"Car"})," class, with ",(0,i.jsx)(n.code,{children:"self.brand"})," set to ",(0,i.jsx)(n.code,{children:'"BMW"'})," and ",(0,i.jsx)(n.code,{children:"self.fuel_type"})," set to ",(0,i.jsx)(n.code,{children:'"Electric"'}),". The ",(0,i.jsx)(n.code,{children:"volvo"})," and ",(0,i.jsx)(n.code,{children:"bmw"})," instances are independent of each other, each maintaining its own brand and fuel type."]}),"\n",(0,i.jsxs)(n.h3,{id:"self-in-instance-methods",children:[(0,i.jsx)(n.code,{children:"self"})," in Instance Methods"]}),"\n",(0,i.jsxs)(n.p,{children:["When defining instance methods (i.e., methods that operate on an instance of a class), ",(0,i.jsx)(n.code,{children:"self"})," is used to access and modify the instance's attributes and invoke other methods. For example:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'class Car:\n    def __init__(self, brand: str, fuel_type: str) -> None:\n        self.brand = brand\n        self.fuel_type = fuel_type\n\n    def drive(self, distance: float) -> None:\n        print(f"Driving {self.brand} for {distance} km on {self.fuel_type}")\n'})}),"\n",(0,i.jsx)(n.p,{children:"Here:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"self.brand"})," and ",(0,i.jsx)(n.code,{children:"self.fuel_type"})," allow the ",(0,i.jsx)(n.code,{children:"drive"})," method to access the instance-specific attributes."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["When you call ",(0,i.jsx)(n.code,{children:"volvo.drive(10)"}),", Python automatically passes the ",(0,i.jsx)(n.code,{children:"volvo"})," instance as the ",(0,i.jsx)(n.code,{children:"self"})," parameter to the ",(0,i.jsx)(n.code,{children:"drive"})," method, resulting in the output:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Driving Volvo for 10 km on Diesel\n"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This demonstrates how methods can operate on data specific to the instance from which they are called."}),"\n",(0,i.jsxs)(n.h3,{id:"the-naming-convention-of-self",children:["The Naming Convention of ",(0,i.jsx)(n.code,{children:"self"})]}),"\n",(0,i.jsxs)(n.p,{children:["It's crucial to understand that ",(0,i.jsx)(n.code,{children:"self"})," is not a reserved keyword in Python; it is simply a convention that signals to other developers (and to yourself) that this parameter refers to the instance of the class. You can name this parameter anything, though using ",(0,i.jsx)(n.code,{children:"self"})," is highly recommended for readability and consistency."]}),"\n",(0,i.jsx)(n.p,{children:"Consider this unconventional example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'class Car:\n    def __init__(this, brand: str, fuel_type: str) -> None:\n        this.brand = brand\n        this.fuel_type = fuel_type\n\n    def drive(this, distance: float) -> None:\n        print(f"Driving {this.brand} for {distance} km on {this.fuel_type}")\n'})}),"\n",(0,i.jsxs)(n.p,{children:["The code will work identically, but naming the parameter ",(0,i.jsx)(n.code,{children:"this"})," instead of ",(0,i.jsx)(n.code,{children:"self"})," may confuse other developers who are accustomed to the convention."]}),"\n",(0,i.jsx)(n.h3,{id:"self-is-implicitly-passed",children:"Self is Implicitly Passed"}),"\n",(0,i.jsxs)(n.p,{children:["A key aspect of ",(0,i.jsx)(n.code,{children:"self"})," is that Python implicitly passes it when you call an instance method. For instance:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"volvo.drive(10)\n"})}),"\n",(0,i.jsx)(n.p,{children:"Python interprets this as:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"Car.drive(volvo, 10)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Thus, ",(0,i.jsx)(n.code,{children:"self"})," is automatically set to the instance ",(0,i.jsx)(n.code,{children:"volvo"}),". Attempting to pass ",(0,i.jsx)(n.code,{children:"self"})," explicitly like this would raise an error because Python expects ",(0,i.jsx)(n.code,{children:"self"})," to be handled automatically."]}),"\n",(0,i.jsx)(n.h3,{id:"self-in-constructors-and-other-special-methods",children:"Self in Constructors and Other Special Methods"}),"\n",(0,i.jsxs)(n.p,{children:["In Python, special methods like ",(0,i.jsx)(n.code,{children:"__init__"}),", ",(0,i.jsx)(n.code,{children:"__str__"}),", ",(0,i.jsx)(n.code,{children:"__repr__"}),", and ",(0,i.jsx)(n.code,{children:"__eq__"})," also rely on ",(0,i.jsx)(n.code,{children:"self"})," to operate on the instance. These methods are typically used to define how an object should be initialized, represented as a string, compared, and so on."]}),"\n",(0,i.jsxs)(n.p,{children:["For example, consider the ",(0,i.jsx)(n.code,{children:"__str__"})," method, which defines how an object should be printed:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'class Car:\n    def __init__(self, brand: str, fuel_type: str) -> None:\n        self.brand = brand\n        self.fuel_type = fuel_type\n\n    def __str__(self) -> str:\n        return f"{self.brand} running on {self.fuel_type}"\n\nvolvo = Car("Volvo", "Diesel")\nprint(volvo)\n'})}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Volvo running on Diesel\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Here, ",(0,i.jsx)(n.code,{children:"self"})," in the ",(0,i.jsx)(n.code,{children:"__str__"})," method ensures that the correct instance-specific data is used when converting the object to a string."]}),"\n",(0,i.jsxs)(n.h2,{id:"advanced-topics-related-to-self",children:["Advanced Topics Related to ",(0,i.jsx)(n.code,{children:"self"})]}),"\n",(0,i.jsx)(n.h3,{id:"class-methods-vs-instance-methods",children:"Class Methods vs. Instance Methods"}),"\n",(0,i.jsxs)(n.p,{children:["While instance methods operate on instances of the class and require ",(0,i.jsx)(n.code,{children:"self"}),", Python also supports class methods, which operate on the class itself and not on instances. Class methods are defined using the ",(0,i.jsx)(n.code,{children:"@classmethod"})," decorator and take ",(0,i.jsx)(n.code,{children:"cls"}),' (another convention, standing for "class") as their first parameter instead of ',(0,i.jsx)(n.code,{children:"self"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"class Car:\n    total_cars = 0\n\n    def __init__(self, brand: str, fuel_type: str) -> None:\n        self.brand = brand\n        self.fuel_type = fuel_type\n        Car.total_cars += 1\n\n    @classmethod\n    def get_total_cars(cls) -> int:\n        return cls.total_cars\n"})}),"\n",(0,i.jsx)(n.p,{children:"Here:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"get_total_cars"})," is a class method, meaning it operates on the class level, using ",(0,i.jsx)(n.code,{children:"cls"})," to refer to the class itself."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"total_cars"})," is a class attribute shared by all instances of the ",(0,i.jsx)(n.code,{children:"Car"})," class."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Class methods are useful for factory methods, counting instances, or accessing/modifying class-level data."}),"\n",(0,i.jsxs)(n.h3,{id:"static-methods-when-self-is-not-needed",children:["Static Methods: When ",(0,i.jsx)(n.code,{children:"self"})," Is Not Needed"]}),"\n",(0,i.jsxs)(n.p,{children:["Static methods are another category of methods that do not operate on either an instance (",(0,i.jsx)(n.code,{children:"self"}),") or the class (",(0,i.jsx)(n.code,{children:"cls"}),"). They are defined using the ",(0,i.jsx)(n.code,{children:"@staticmethod"})," decorator and do not take ",(0,i.jsx)(n.code,{children:"self"})," or ",(0,i.jsx)(n.code,{children:"cls"})," as a parameter."]}),"\n",(0,i.jsx)(n.p,{children:"Example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'class Car:\n    def __init__(self, brand: str, fuel_type: str) -> None:\n        self.brand = brand\n        self.fuel_type = fuel_type\n\n    @staticmethod\n    def display_fuel_types() -> None:\n        print("Available fuel types: Diesel, Electric, Gasoline")\n\nCar.display_fuel_types()\n'})}),"\n",(0,i.jsx)(n.p,{children:"Here:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"display_fuel_types"})," is a static method and can be called without creating an instance of ",(0,i.jsx)(n.code,{children:"Car"}),"."]}),"\n",(0,i.jsx)(n.li,{children:"Static methods are typically utility functions that perform a task in isolation without depending on class or instance-specific data."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"self-in-inheritance-and-method-resolution-order-mro",children:"Self in Inheritance and Method Resolution Order (MRO)"}),"\n",(0,i.jsxs)(n.p,{children:["In Python, ",(0,i.jsx)(n.code,{children:"self"})," is also crucial when dealing with inheritance. When a class inherits from another, the ",(0,i.jsx)(n.code,{children:"self"})," parameter ensures that methods from the base class can be properly invoked on the subclass instances."]}),"\n",(0,i.jsx)(n.p,{children:"Consider the following example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'class Vehicle:\n    def __init__(self, brand: str) -> None:\n        self.brand = brand\n\n    def start(self) -> None:\n        print(f"{self.brand} vehicle is starting.")\n\nclass Car(Vehicle):\n    def __init__(self, brand: str, fuel_type: str) -> None:\n        super().__init__(brand)\n        self.fuel_type = fuel_type\n\n    def start(self) -> None:\n        print(f"{self.brand} car running on {self.fuel_type} is starting.")\n'})}),"\n",(0,i.jsx)(n.p,{children:"Here:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"Car"})," class inherits from ",(0,i.jsx)(n.code,{children:"Vehicle"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"super().__init__(brand)"})," call in ",(0,i.jsx)(n.code,{children:"Car.__init__"})," invokes the ",(0,i.jsx)(n.code,{children:"Vehicle.__init__"})," method to initialize the ",(0,i.jsx)(n.code,{children:"brand"})," attribute, with"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"self"})," ensuring that the correct instance is modified."]}),"\n",(0,i.jsxs)(n.p,{children:["When calling ",(0,i.jsx)(n.code,{children:"start"})," on a ",(0,i.jsx)(n.code,{children:"Car"})," instance:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'tesla = Car("Tesla", "Electric")\ntesla.start()\n'})}),"\n",(0,i.jsx)(n.p,{children:"Output:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"Tesla car running on Electric is starting.\n"})}),"\n",(0,i.jsxs)(n.p,{children:["The method resolution order (MRO) ensures that the ",(0,i.jsx)(n.code,{children:"start"})," method from the ",(0,i.jsx)(n.code,{children:"Car"})," class is used, but ",(0,i.jsx)(n.code,{children:"self"})," guarantees that if the method was not overridden, the ",(0,i.jsx)(n.code,{children:"Vehicle"})," version would still work correctly with the ",(0,i.jsx)(n.code,{children:"Car"})," instance."]}),"\n",(0,i.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(n.h3,{id:"key-points-to-remember",children:"Key Points to Remember"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"self"})," is a reference to the current instance of the class"]}),": It allows methods to access and modify the instance\u2019s attributes and other methods."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"self"})," is automatically passed to instance methods"]}),": Python handles this implicitly, ensuring that the correct instance data is used without the need for explicit passing."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Naming conventions"}),": While ",(0,i.jsx)(n.code,{children:"self"})," is not a keyword, it is the widely accepted convention and should be used to maintain code clarity."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Different types of methods"}),": Instance methods require ",(0,i.jsx)(n.code,{children:"self"}),", class methods require ",(0,i.jsx)(n.code,{children:"cls"}),", and static methods do not require either."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Inheritance and MRO"}),": ",(0,i.jsx)(n.code,{children:"self"})," ensures that inherited methods operate correctly on subclass instances."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"conclusion",children:"Conclusion"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"self"})," parameter in Python is integral to the correct functioning of object-oriented programming within the language. It provides the mechanism by which instances of classes maintain their own state and behavior, enabling the powerful and flexible design patterns that OOP allows. By fully understanding ",(0,i.jsx)(n.code,{children:"self"}),", you gain a deeper insight into Python\u2019s class mechanics, empowering you to write more effective and maintainable code."]})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(a,{...e})}):a(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>c});var t=s(6540);const i={},l=t.createContext(i);function o(e){const n=t.useContext(l);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),t.createElement(l.Provider,{value:n},e.children)}}}]);