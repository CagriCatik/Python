"use strict";(self.webpackChunkmy_docusaurus_site=self.webpackChunkmy_docusaurus_site||[]).push([[2363],{4262:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"guide/Multiprocessing/Intro","title":"Introduction","description":"In this tutorial, we will explore the concepts of asynchronous programming, multithreading, and multiprocessing in Python. This foundational knowledge is essential for efficient and effective utilization of Python\u2019s concurrency capabilities. The following sections provide an in-depth comparison of these paradigms, followed by practical code examples to illustrate their usage.","source":"@site/docs/guide/12_Multiprocessing/01_Intro.md","sourceDirName":"guide/12_Multiprocessing","slug":"/guide/Multiprocessing/Intro","permalink":"/Python/docs/guide/Multiprocessing/Intro","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/guide/12_Multiprocessing/01_Intro.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{},"sidebar":"guideSidebar","previous":{"title":"Multiprocessing","permalink":"/Python/docs/category/multiprocessing"},"next":{"title":"Multiprocessing","permalink":"/Python/docs/guide/Multiprocessing/Processes"}}');var s=i(4848),r=i(8453);const o={},a="Introduction",l={},c=[{value:"Asynchronous Programming",id:"asynchronous-programming",level:2},{value:"Key Characteristics:",id:"key-characteristics",level:2},{value:"Example Code:",id:"example-code",level:2},{value:"Multithreading",id:"multithreading",level:2},{value:"Key Characteristics:",id:"key-characteristics-1",level:2},{value:"Example Code:",id:"example-code-1",level:2},{value:"Multiprocessing",id:"multiprocessing",level:2},{value:"Key Characteristics:",id:"key-characteristics-2",level:2},{value:"Example Code:",id:"example-code-2",level:2},{value:"Comparison of Concurrency Paradigms",id:"comparison-of-concurrency-paradigms",level:2},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"introduction",children:"Introduction"})}),"\n",(0,s.jsx)(n.p,{children:"In this tutorial, we will explore the concepts of asynchronous programming, multithreading, and multiprocessing in Python. This foundational knowledge is essential for efficient and effective utilization of Python\u2019s concurrency capabilities. The following sections provide an in-depth comparison of these paradigms, followed by practical code examples to illustrate their usage."}),"\n",(0,s.jsx)(n.h2,{id:"asynchronous-programming",children:"Asynchronous Programming"}),"\n",(0,s.jsx)(n.p,{children:"Asynchronous programming allows for non-blocking execution, where tasks can pause (e.g., waiting for an I/O operation to complete) and resume without blocking the main thread. This is particularly useful for I/O-bound tasks."}),"\n",(0,s.jsx)(n.h2,{id:"key-characteristics",children:"Key Characteristics:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Single-threaded."}),"\n",(0,s.jsx)(n.li,{children:"Non-blocking: Tasks can be paused and resumed, allowing other tasks to run during the wait time."}),"\n",(0,s.jsx)(n.li,{children:"Managed by the code (application level) rather than the operating system."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"example-code",children:"Example Code:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'import asyncio\n\nasync def fetch_data():\n    print("Start fetching data")\n    await asyncio.sleep(2)  # Simulating an I/O operation with sleep\n    print("Done fetching data")\n    return "Data"\n\nasync def main():\n    data = await fetch_data()\n    print(f"Fetched: {data}")\n\n# Run the asynchronous event loop\nasyncio.run(main())\n'})}),"\n",(0,s.jsx)(n.h2,{id:"multithreading",children:"Multithreading"}),"\n",(0,s.jsx)(n.p,{children:"Multithreading allows multiple threads to run concurrently. This is beneficial for I/O-bound tasks, but due to Python's Global Interpreter Lock (GIL), it does not provide true parallelism for CPU-bound tasks."}),"\n",(0,s.jsx)(n.h2,{id:"key-characteristics-1",children:"Key Characteristics:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Multiple threads running concurrently."}),"\n",(0,s.jsx)(n.li,{children:"Suitable for I/O-bound tasks."}),"\n",(0,s.jsx)(n.li,{children:"GIL restricts true parallel execution of threads in CPU-bound tasks."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"example-code-1",children:"Example Code:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"import threading\nimport time\n\ndef print_numbers():\n    for i in range(5):\n        time.sleep(1)\n        print(i)\n\ndef print_letters():\n    for letter in 'ABCDE':\n        time.sleep(1.5)\n        print(letter)\n\n# Creating threads\nthread1 = threading.Thread(target=print_numbers)\nthread2 = threading.Thread(target=print_letters)\n\n# Starting threads\nthread1.start()\nthread2.start()\n\n# Waiting for both threads to finish\nthread1.join()\nthread2.join()\n"})}),"\n",(0,s.jsx)(n.h2,{id:"multiprocessing",children:"Multiprocessing"}),"\n",(0,s.jsx)(n.p,{children:"Multiprocessing involves running multiple processes in parallel, each with its own Python interpreter and memory space. This is particularly useful for CPU-bound tasks as it bypasses the GIL, allowing true parallel execution."}),"\n",(0,s.jsx)(n.h2,{id:"key-characteristics-2",children:"Key Characteristics:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Multiple processes running in parallel."}),"\n",(0,s.jsx)(n.li,{children:"Suitable for CPU-bound tasks."}),"\n",(0,s.jsx)(n.li,{children:"Each process has its own memory space and GIL instance."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"example-code-2",children:"Example Code:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"from multiprocessing import Process\nimport os\n\ndef print_process_info(name):\n    print(f'Process name: {name}, Process ID: {os.getpid()}')\n\nif __name__ == '__main__':\n    processes = []\n    for i in range(5):\n        process = Process(target=print_process_info, args=(f'Process-{i}',))\n        processes.append(process)\n        process.start()\n\n    for process in processes:\n        process.join()\n"})}),"\n",(0,s.jsx)(n.h2,{id:"comparison-of-concurrency-paradigms",children:"Comparison of Concurrency Paradigms"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Feature"}),(0,s.jsx)(n.th,{children:"Asynchronous Programming"}),(0,s.jsx)(n.th,{children:"Multithreading"}),(0,s.jsx)(n.th,{children:"Multiprocessing"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Execution Model"}),(0,s.jsx)(n.td,{children:"Single-threaded, non-blocking"}),(0,s.jsx)(n.td,{children:"Multiple threads, concurrency"}),(0,s.jsx)(n.td,{children:"Multiple processes, parallelism"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Suitable for"}),(0,s.jsx)(n.td,{children:"I/O-bound tasks"}),(0,s.jsx)(n.td,{children:"I/O-bound tasks"}),(0,s.jsx)(n.td,{children:"CPU-bound tasks"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"GIL Impact"}),(0,s.jsx)(n.td,{children:"Not impacted"}),(0,s.jsx)(n.td,{children:"Restricted by GIL"}),(0,s.jsx)(n.td,{children:"Not impacted (each process has its own GIL)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Memory Space"}),(0,s.jsx)(n.td,{children:"Shared"}),(0,s.jsx)(n.td,{children:"Shared"}),(0,s.jsx)(n.td,{children:"Separate"})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsx)(n.p,{children:"Understanding the differences between asynchronous programming, multithreading, and multiprocessing is crucial for optimizing the performance of Python applications. Asynchronous programming excels in handling I/O-bound tasks without blocking the main thread. Multithreading is also effective for I/O-bound tasks but is limited by the GIL for CPU-bound tasks. Multiprocessing, on the other hand, provides true parallelism by running multiple processes, each with its own memory space and GIL instance, making it ideal for CPU-bound tasks."}),"\n",(0,s.jsxs)(n.p,{children:["In subsequent lessons, we will delve deeper into practical applications and advanced techniques for utilizing the ",(0,s.jsx)(n.code,{children:"multiprocessing"})," module in Python, enabling you to harness the full power of modern multi-core processors."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>o,x:()=>a});var t=i(6540);const s={},r=t.createContext(s);function o(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);