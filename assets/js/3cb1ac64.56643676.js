"use strict";(self.webpackChunkpython=self.webpackChunkpython||[]).push([[104],{4346:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"solid/isp","title":"Interface Segregation Principle","description":"The Interface Segregation Principle (ISP) is one of the core SOLID design principles. It states that clients should not be forced to depend on interfaces they do not use. In essence, rather than having one large, monolithic interface, it is preferable to have multiple smaller, specific interfaces. This approach prevents classes from being burdened with methods that are irrelevant to their purpose.","source":"@site/docs/solid/04_isp.md","sourceDirName":"solid","slug":"/solid/isp","permalink":"/Python/docs/solid/isp","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/solid/04_isp.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{},"sidebar":"solidSidebar","previous":{"title":"Liskov Substitution Principle","permalink":"/Python/docs/solid/lsp"},"next":{"title":"Dependency Inversion Principle","permalink":"/Python/docs/solid/dip"}}');var s=i(4848),o=i(8453);const a={},r="Interface Segregation Principle",c={},d=[{value:"What is ISP?",id:"what-is-isp",level:2},{value:"Importance of ISP in Automotive Software",id:"importance-of-isp-in-automotive-software",level:2},{value:"Automotive Example: Infotainment System",id:"automotive-example-infotainment-system",level:2},{value:"Bad Practice Example",id:"bad-practice-example",level:3},{value:"Best Practice Example",id:"best-practice-example",level:3},{value:"Conclusion",id:"conclusion",level:2}];function l(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"interface-segregation-principle",children:"Interface Segregation Principle"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.strong,{children:"Interface Segregation Principle (ISP)"})," is one of the core SOLID design principles. It states that ",(0,s.jsx)(n.strong,{children:"clients should not be forced to depend on interfaces they do not use"}),". In essence, rather than having one large, monolithic interface, it is preferable to have multiple smaller, specific interfaces. This approach prevents classes from being burdened with methods that are irrelevant to their purpose."]}),"\n",(0,s.jsx)(n.p,{children:"In the automotive industry, where software systems may run on resource-constrained embedded devices and need to interact with a variety of subsystems (like infotainment, navigation, audio, and connectivity), ISP is especially important. By dividing responsibilities into focused interfaces, developers create systems that are more modular, easier to maintain, and less prone to errors."}),"\n",(0,s.jsx)(n.h2,{id:"what-is-isp",children:"What is ISP?"}),"\n",(0,s.jsx)(n.p,{children:"ISP promotes the design of lean interfaces that are client-specific. Instead of one large interface that covers many functionalities, each interface should contain only the methods that are relevant for a particular client. This ensures that a class implementing an interface is not forced to provide irrelevant or dummy implementations of methods it does not require."}),"\n",(0,s.jsx)(n.h2,{id:"importance-of-isp-in-automotive-software",children:"Importance of ISP in Automotive Software"}),"\n",(0,s.jsx)(n.p,{children:"In automotive systems, components often have distinct functionalities. For instance, consider an infotainment system that handles audio playback, navigation, and phone connectivity:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Embedded Constraints:"})," Many automotive devices have limited processing power and memory. Implementing a fat interface can lead to unnecessary overhead."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Modularity:"})," By splitting functionality, each module (audio, navigation, connectivity) can evolve independently."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Maintainability:"})," When responsibilities are well separated, changes in one module (e.g., updating the navigation interface) do not force changes in unrelated modules (e.g., the audio player)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Reliability:"})," Reducing dependencies on irrelevant methods minimizes the risk of runtime errors and improves overall system stability."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"automotive-example-infotainment-system",children:"Automotive Example: Infotainment System"}),"\n",(0,s.jsxs)(n.p,{children:["Consider an infotainment system for a car. A ",(0,s.jsx)(n.strong,{children:"bad design"})," might force every component to implement methods for audio, navigation, and connectivity\u2014even if a component only handles one of these tasks. This violates ISP because the client (e.g., a basic audio unit) is forced to depend on an interface that includes methods it doesn't use."]}),"\n",(0,s.jsx)(n.h3,{id:"bad-practice-example",children:"Bad Practice Example"}),"\n",(0,s.jsxs)(n.p,{children:["In this example, the ",(0,s.jsx)(n.code,{children:"InfotainmentSystem"})," interface contains methods for all infotainment functionalities. A ",(0,s.jsx)(n.code,{children:"BasicAudioUnit"})," class, which only needs to play music, is forced to provide implementations (even if dummy) for navigation and connectivity."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'from abc import ABC, abstractmethod\n\nclass InfotainmentSystem(ABC):\n    @abstractmethod\n    def play_music(self, song: str) -> None:\n        """\n        Plays a music track.\n        """\n        pass\n\n    @abstractmethod\n    def display_map(self, destination: str) -> None:\n        """\n        Displays a map for navigation.\n        """\n        pass\n\n    @abstractmethod\n    def connect_phone(self, device: str) -> None:\n        """\n        Connects to a phone for communication.\n        """\n        pass\n\nclass BasicAudioUnit(InfotainmentSystem):\n    def play_music(self, song: str) -> None:\n        print(f"Playing \'{song}\' through car speakers")\n\n    def display_map(self, destination: str) -> None:\n        # BasicAudioUnit does not support navigation.\n        print("Navigation not supported on BasicAudioUnit")\n\n    def connect_phone(self, device: str) -> None:\n        # BasicAudioUnit does not support phone connectivity.\n        print("Phone connectivity not supported on BasicAudioUnit")\n\n# Usage of the bad design:\naudio_unit = BasicAudioUnit()\naudio_unit.play_music("Imagine - John Lennon")\naudio_unit.display_map("123 Main St")  # Irrelevant for an audio unit\naudio_unit.connect_phone("DeviceXYZ")    # Irrelevant for an audio unit\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Issues with the Bad Example:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Irrelevant Methods:"})," ",(0,s.jsx)(n.code,{children:"BasicAudioUnit"})," is forced to implement methods for navigation and connectivity even though it does not need these features."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Wasted Resources:"})," Implementing and maintaining unused functionality can lead to bloated code and potential runtime errors."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Inflexibility:"})," Clients must rely on a large interface that doesn't match their actual requirements."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"best-practice-example",children:"Best Practice Example"}),"\n",(0,s.jsxs)(n.p,{children:["By applying ISP, we can split the large ",(0,s.jsx)(n.code,{children:"InfotainmentSystem"})," interface into smaller, more focused interfaces. For example, we can define separate interfaces for audio, navigation, and connectivity. A component such as ",(0,s.jsx)(n.code,{children:"BasicAudioUnit"})," would only implement the ",(0,s.jsx)(n.code,{children:"AudioSystem"})," interface."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'from abc import ABC, abstractmethod\n\nclass AudioSystem(ABC):\n    @abstractmethod\n    def play_music(self, song: str) -> None:\n        """\n        Plays a music track.\n        """\n        pass\n\nclass NavigationSystem(ABC):\n    @abstractmethod\n    def display_map(self, destination: str) -> None:\n        """\n        Displays a map for navigation.\n        """\n        pass\n\nclass ConnectivitySystem(ABC):\n    @abstractmethod\n    def connect_phone(self, device: str) -> None:\n        """\n        Connects to a phone for communication.\n        """\n        pass\n\nclass BasicAudioUnit(AudioSystem):\n    def play_music(self, song: str) -> None:\n        print(f"Playing \'{song}\' through car speakers")\n\n# Usage of the ISP-compliant design:\naudio_unit = BasicAudioUnit()\naudio_unit.play_music("Imagine - John Lennon")\n# Note: BasicAudioUnit is not concerned with navigation or connectivity,\n# so it doesn\'t implement or even know about those methods.\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Benefits of the Best Practice Example:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Focused Interfaces:"})," ",(0,s.jsx)(n.code,{children:"BasicAudioUnit"})," implements only the ",(0,s.jsx)(n.code,{children:"AudioSystem"})," interface, containing only the methods it needs."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Reduced Complexity:"})," Clients are not burdened with irrelevant methods, making the code more intuitive and maintainable."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Enhanced Flexibility:"})," New functionalities (such as advanced navigation or connectivity) can be added as separate modules without affecting components that don't require them."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Resource Efficiency:"})," Leaner interfaces can be particularly beneficial for embedded automotive systems with limited resources."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsx)(n.p,{children:"The Interface Segregation Principle is essential for designing modular and efficient automotive software. By ensuring that clients only depend on the interfaces they actually use, developers can create systems that are:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Easier to maintain:"})," Changes in one aspect (e.g., navigation) do not affect unrelated functionalities (e.g., audio)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"More reliable:"})," Reduced coupling minimizes the chance of introducing errors."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Resource-friendly:"})," Especially important in automotive systems where hardware resources may be limited."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Applying ISP in automotive applications, such as an infotainment system, leads to clearer, more robust designs that are easier to extend and maintain. This approach not only simplifies the development process but also enhances the overall quality and performance of the software, ensuring that each component does exactly what it is supposed to do\u2014and nothing more."})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>r});var t=i(6540);const s={},o=t.createContext(s);function a(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);