"use strict";(self.webpackChunkpython=self.webpackChunkpython||[]).push([[8411],{9156:(e,a,s)=>{s.r(a),s.d(a,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>c,metadata:()=>n,toc:()=>r});const n=JSON.parse('{"id":"python-guide/Dataclasses/@dataclass","title":"Data Classes","description":"Data classes in Python offer a convenient way to create classes whose main purpose is to hold and represent data. While you can achieve similar functionality using regular classes, data classes provide enhanced readability, comparability, and reduce boilerplate code. To begin, let\'s import the dataclass decorator from the dataclasses module. We will use this decorator to create our data class.","source":"@site/docs/python-guide/09_Dataclasses/01_@dataclass.md","sourceDirName":"python-guide/09_Dataclasses","slug":"/python-guide/Dataclasses/@dataclass","permalink":"/Python/docs/python-guide/Dataclasses/@dataclass","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/python-guide/09_Dataclasses/01_@dataclass.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{},"sidebar":"guideSidebar","previous":{"title":"Dataclasses","permalink":"/Python/docs/category/dataclasses"},"next":{"title":"Data Class with Mutable Defaults","permalink":"/Python/docs/python-guide/Dataclasses/Fields"}}');var t=s(4848),i=s(8453);const c={},l="Data Classes",o={},r=[{value:"Creating a Data Class",id:"creating-a-data-class",level:2},{value:"Creating Instances",id:"creating-instances",level:2},{value:"Benefits of Data Classes",id:"benefits-of-data-classes",level:2},{value:"Comparison with Regular Classes",id:"comparison-with-regular-classes",level:2},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const a={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(a.header,{children:(0,t.jsx)(a.h1,{id:"data-classes",children:"Data Classes"})}),"\n",(0,t.jsxs)(a.p,{children:["Data classes in Python offer a convenient way to create classes whose main purpose is to hold and represent data. While you can achieve similar functionality using regular classes, data classes provide enhanced readability, comparability, and reduce boilerplate code. To begin, let's import the ",(0,t.jsx)(a.code,{children:"dataclass"})," decorator from the ",(0,t.jsx)(a.code,{children:"dataclasses"})," module. We will use this decorator to create our data class."]}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-python",children:"from dataclasses import dataclass\n"})}),"\n",(0,t.jsx)(a.h2,{id:"creating-a-data-class",children:"Creating a Data Class"}),"\n",(0,t.jsx)(a.p,{children:"Suppose we want to track information about different cryptocurrencies, including their ID, value, and name. We can model this data using a data class."}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-python",children:"@dataclass\nclass Coin:\n    name: str\n    value: float\n    id: str\n"})}),"\n",(0,t.jsx)(a.p,{children:"In the above code:"}),"\n",(0,t.jsxs)(a.ul,{children:["\n",(0,t.jsxs)(a.li,{children:["We annotate our class with ",(0,t.jsx)(a.code,{children:"@dataclass"})," to indicate it is a data class."]}),"\n",(0,t.jsxs)(a.li,{children:["We define attributes (",(0,t.jsx)(a.code,{children:"name"}),", ",(0,t.jsx)(a.code,{children:"value"}),", and ",(0,t.jsx)(a.code,{children:"id"}),") along with their types."]}),"\n"]}),"\n",(0,t.jsx)(a.h2,{id:"creating-instances",children:"Creating Instances"}),"\n",(0,t.jsxs)(a.p,{children:["Now, let's create instances of our ",(0,t.jsx)(a.code,{children:"Coin"})," class and initialize them with relevant data."]}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-python",children:'if __name__ == "__main__":\n    bitcoin = Coin("Bitcoin", 10000, "BTC")\n    bitcoin_two = Coin("Bitcoin", 10000, "BTC")\n    ripple = Coin("Ripple", 200, "XRP")\n'})}),"\n",(0,t.jsxs)(a.p,{children:["We've created instances of coins, namely ",(0,t.jsx)(a.code,{children:"bitcoin"}),", ",(0,t.jsx)(a.code,{children:"bitcoin_two"}),", and ",(0,t.jsx)(a.code,{children:"ripple"}),", using the ",(0,t.jsx)(a.code,{children:"Coin"})," class."]}),"\n",(0,t.jsx)(a.h2,{id:"benefits-of-data-classes",children:"Benefits of Data Classes"}),"\n",(0,t.jsxs)(a.ul,{children:["\n",(0,t.jsxs)(a.li,{children:[(0,t.jsx)(a.strong,{children:"Readability"}),": Data classes provide readable representations of objects, making it easy to inspect their attributes."]}),"\n",(0,t.jsxs)(a.li,{children:[(0,t.jsx)(a.strong,{children:"Comparability"}),": Comparing objects becomes more straightforward with data classes. Python automatically compares the attributes when using comparison operators."]}),"\n",(0,t.jsxs)(a.li,{children:[(0,t.jsx)(a.strong,{children:"Reduced Boilerplate"}),": Data classes eliminate the need for writing boilerplate code for ",(0,t.jsx)(a.code,{children:"__init__"}),", ",(0,t.jsx)(a.code,{children:"__repr__"}),", and ",(0,t.jsx)(a.code,{children:"__eq__"})," methods."]}),"\n"]}),"\n",(0,t.jsx)(a.h2,{id:"comparison-with-regular-classes",children:"Comparison with Regular Classes"}),"\n",(0,t.jsx)(a.p,{children:"Let's compare our data class with a regular class to understand the advantages better."}),"\n",(0,t.jsx)(a.pre,{children:(0,t.jsx)(a.code,{className:"language-python",children:"class Coin:\n    def __init__(self, name: str, value: float, coin_id: str):\n        self.name = name\n        self.value = value\n        self.coin_id = coin_id\n"})}),"\n",(0,t.jsx)(a.p,{children:"In the regular class:"}),"\n",(0,t.jsxs)(a.ul,{children:["\n",(0,t.jsxs)(a.li,{children:["We manually define the ",(0,t.jsx)(a.code,{children:"__init__"})," method to initialize attributes."]}),"\n",(0,t.jsx)(a.li,{children:"Comparison and representation methods need to be explicitly defined for meaningful outputs."}),"\n"]}),"\n",(0,t.jsx)(a.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,t.jsx)(a.p,{children:"In conclusion, data classes offer a concise and efficient way to manage data-centric classes in Python. They enhance code readability, comparability, and reduce development time by minimizing boilerplate code."})]})}function h(e={}){const{wrapper:a}={...(0,i.R)(),...e.components};return a?(0,t.jsx)(a,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,a,s)=>{s.d(a,{R:()=>c,x:()=>l});var n=s(6540);const t={},i=n.createContext(t);function c(e){const a=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function l(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:c(e.components),n.createElement(i.Provider,{value:a},e.children)}}}]);