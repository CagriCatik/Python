"use strict";(self.webpackChunkmy_docusaurus_site=self.webpackChunkmy_docusaurus_site||[]).push([[3514],{8364:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"design-patterns/creational","title":"Creational Design Patterns","description":"Creational design patterns are a category of design patterns in software engineering that deal with object creation mechanisms. They provide solutions to common problems related to object creation, such as managing complexity, ensuring flexibility, and improving scalability. In this tutorial, we will explore three fundamental creational design patterns: Singleton, Factory, and Builder.","source":"@site/docs/design-patterns/creational.md","sourceDirName":"design-patterns","slug":"/design-patterns/creational","permalink":"/Python/docs/design-patterns/creational","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/design-patterns/creational.md","tags":[],"version":"current","frontMatter":{},"sidebar":"designPatternsSidebar","previous":{"title":"builder","permalink":"/Python/docs/design-patterns/builder"}}');var s=t(4848),r=t(8453);const a={},o="Creational Design Patterns",l={},c=[{value:"1. Singleton Pattern",id:"1-singleton-pattern",level:2},{value:"Key Features:",id:"key-features",level:3},{value:"Implementation:",id:"implementation",level:3},{value:"Usage:",id:"usage",level:3},{value:"Use Cases:",id:"use-cases",level:3},{value:"2. Factory Pattern",id:"2-factory-pattern",level:2},{value:"Key Features:",id:"key-features-1",level:3},{value:"Implementation:",id:"implementation-1",level:3},{value:"Usage:",id:"usage-1",level:3},{value:"Use Cases:",id:"use-cases-1",level:3},{value:"3. Builder Pattern",id:"3-builder-pattern",level:2},{value:"Key Features:",id:"key-features-2",level:3},{value:"Implementation:",id:"implementation-2",level:3},{value:"Usage:",id:"usage-2",level:3},{value:"Use Cases:",id:"use-cases-2",level:3},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"creational-design-patterns",children:"Creational Design Patterns"})}),"\n",(0,s.jsx)(n.p,{children:"Creational design patterns are a category of design patterns in software engineering that deal with object creation mechanisms. They provide solutions to common problems related to object creation, such as managing complexity, ensuring flexibility, and improving scalability. In this tutorial, we will explore three fundamental creational design patterns: Singleton, Factory, and Builder."}),"\n",(0,s.jsx)(n.h2,{id:"1-singleton-pattern",children:"1. Singleton Pattern"}),"\n",(0,s.jsx)(n.p,{children:"The Singleton pattern ensures that a class has only one instance and provides a global point of access to that instance. It is useful when you want to restrict the instantiation of a class to a single object, which can be shared across the entire application."}),"\n",(0,s.jsx)(n.h3,{id:"key-features",children:"Key Features:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Private constructor to prevent direct instantiation of the class."}),"\n",(0,s.jsx)(n.li,{children:"Static member variable to hold the single instance of the class."}),"\n",(0,s.jsx)(n.li,{children:"Static method to provide global access to the instance."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"implementation",children:"Implementation:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'class Singleton:\n    _instance = None\n  \n    @staticmethod\n    def get_instance():\n        if Singleton._instance is None:\n            Singleton._instance = Singleton()\n        return Singleton._instance\n  \n    def __init__(self):\n        if Singleton._instance is not None:\n            raise Exception("This class is a singleton!")\n'})}),"\n",(0,s.jsx)(n.h3,{id:"usage",children:"Usage:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"singleton_instance = Singleton.get_instance()\n"})}),"\n",(0,s.jsx)(n.h3,{id:"use-cases",children:"Use Cases:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Logging mechanisms."}),"\n",(0,s.jsx)(n.li,{children:"Database connection management."}),"\n",(0,s.jsx)(n.li,{children:"Configuration settings."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"2-factory-pattern",children:"2. Factory Pattern"}),"\n",(0,s.jsx)(n.p,{children:"The Factory pattern defines an interface for creating objects but lets subclasses alter the type of objects that will be created. It provides a way to delegate the instantiation logic to child classes, thereby promoting loose coupling and enhancing flexibility."}),"\n",(0,s.jsx)(n.h3,{id:"key-features-1",children:"Key Features:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"A common interface for creating objects."}),"\n",(0,s.jsx)(n.li,{children:"Subclasses that implement the interface to provide different implementations."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"implementation-1",children:"Implementation:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'from abc import ABC, abstractmethod\n\nclass Product(ABC):\n    @abstractmethod\n    def operation(self):\n        pass\n\nclass ConcreteProductA(Product):\n    def operation(self):\n        return "ConcreteProductA operation"\n\nclass ConcreteProductB(Product):\n    def operation(self):\n        return "ConcreteProductB operation"\n\nclass Factory(ABC):\n    @abstractmethod\n    def create_product(self):\n        pass\n\nclass ConcreteFactoryA(Factory):\n    def create_product(self):\n        return ConcreteProductA()\n\nclass ConcreteFactoryB(Factory):\n    def create_product(self):\n        return ConcreteProductB()\n'})}),"\n",(0,s.jsx)(n.h3,{id:"usage-1",children:"Usage:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'factory_a = ConcreteFactoryA()\nproduct_a = factory_a.create_product()\nprint(product_a.operation())  # Output: "ConcreteProductA operation"\n'})}),"\n",(0,s.jsx)(n.h3,{id:"use-cases-1",children:"Use Cases:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Object creation that requires complex logic or configuration."}),"\n",(0,s.jsx)(n.li,{children:"Dependency injection frameworks."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"3-builder-pattern",children:"3. Builder Pattern"}),"\n",(0,s.jsx)(n.p,{children:"The Builder pattern separates the construction of a complex object from its representation, allowing the same construction process to create different representations of the object. It is particularly useful when an object requires multiple steps for construction or when there are many configuration options."}),"\n",(0,s.jsx)(n.h3,{id:"key-features-2",children:"Key Features:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Director class to manage the construction process."}),"\n",(0,s.jsx)(n.li,{children:"Builder interface with methods for constructing parts of the object."}),"\n",(0,s.jsx)(n.li,{children:"Concrete builder classes that implement the builder interface to provide specific construction implementations."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"implementation-2",children:"Implementation:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'class Product:\n    def __init__(self):\n        self.part_a = None\n        self.part_b = None\n\nclass Builder:\n    def build_part_a(self):\n        pass\n\n    def build_part_b(self):\n        pass\n\nclass ConcreteBuilder1(Builder):\n    def __init__(self):\n        self.product = Product()\n\n    def build_part_a(self):\n        self.product.part_a = "Part A1"\n\n    def build_part_b(self):\n        self.product.part_b = "Part B1"\n\nclass ConcreteBuilder2(Builder):\n    def __init__(self):\n        self.product = Product()\n\n    def build_part_a(self):\n        self.product.part_a = "Part A2"\n\n    def build_part_b(self):\n        self.product.part_b = "Part B2"\n\nclass Director:\n    def __init__(self, builder):\n        self.builder = builder\n\n    def construct(self):\n        self.builder.build_part_a()\n        self.builder.build_part_b()\n        return self.builder.product\n'})}),"\n",(0,s.jsx)(n.h3,{id:"usage-2",children:"Usage:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'builder1 = ConcreteBuilder1()\ndirector = Director(builder1)\nproduct1 = director.construct()\nprint(product1.part_a)  # Output: "Part A1"\nprint(product1.part_b)  # Output: "Part B1"\n'})}),"\n",(0,s.jsx)(n.h3,{id:"use-cases-2",children:"Use Cases:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Building complex objects with multiple configuration options."}),"\n",(0,s.jsx)(n.li,{children:"Construction of objects with a step-by-step approach."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsx)(n.p,{children:"Creational design patterns provide solutions to common problems related to object creation in software development. By understanding and implementing patterns like Singleton, Factory, and Builder, developers can improve code organization, maintainability, and flexibility in their applications. These patterns offer proven techniques for managing object creation complexity and promoting best practices in software design."})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var i=t(6540);const s={},r=i.createContext(s);function a(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);