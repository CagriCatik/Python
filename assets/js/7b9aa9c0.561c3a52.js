"use strict";(self.webpackChunkmy_docusaurus_site=self.webpackChunkmy_docusaurus_site||[]).push([[1353],{1654:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>o});const s=JSON.parse('{"id":"guide/Python_Basics/VS_Is/README","title":"Understanding Equality vs. Identity in Python","description":"One common mistake among beginners learning Python is the confusion between the equality operator (==) and the identity operator (is). While they serve similar purposes, their usage and behavior are distinctly different. This tutorial will elucidate these differences, illustrate their correct applications, and highlight common pitfalls.","source":"@site/docs/guide/01_Python_Basics/31_VS_Is/README.md","sourceDirName":"guide/01_Python_Basics/31_VS_Is","slug":"/guide/Python_Basics/VS_Is/","permalink":"/Python/docs/guide/Python_Basics/VS_Is/","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/guide/01_Python_Basics/31_VS_Is/README.md","tags":[],"version":"current","frontMatter":{},"sidebar":"guideSidebar","previous":{"title":"Unpacking in Python","permalink":"/Python/docs/guide/Python_Basics/Unpacking/"},"next":{"title":"Control Flow","permalink":"/Python/docs/category/control-flow"}}');var t=i(4848),r=i(8453);const a={},l="Understanding Equality vs. Identity in Python",c={},o=[{value:"Equality Operator (<code>==</code>)",id:"equality-operator-",level:2},{value:"Example:",id:"example",level:2},{value:"Identity Operator (<code>is</code>)",id:"identity-operator-is",level:2},{value:"Example:",id:"example-1",level:2},{value:"Small Integer Caching",id:"small-integer-caching",level:2},{value:"Example:",id:"example-2",level:2},{value:"Demonstrating the Difference with Larger Integers",id:"demonstrating-the-difference-with-larger-integers",level:2},{value:"Using <code>is</code> with Immutable Types",id:"using-is-with-immutable-types",level:2},{value:"Example:",id:"example-3",level:2},{value:"Object Identity with Custom Classes",id:"object-identity-with-custom-classes",level:2},{value:"Example:",id:"example-4",level:2},{value:"Conclusion",id:"conclusion",level:2},{value:"Summary",id:"summary",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"understanding-equality-vs-identity-in-python",children:"Understanding Equality vs. Identity in Python"})}),"\n",(0,t.jsxs)(n.p,{children:["One common mistake among beginners learning Python is the confusion between the equality operator (",(0,t.jsx)(n.code,{children:"=="}),") and the identity operator (",(0,t.jsx)(n.code,{children:"is"}),"). While they serve similar purposes, their usage and behavior are distinctly different. This tutorial will elucidate these differences, illustrate their correct applications, and highlight common pitfalls."]}),"\n",(0,t.jsxs)(n.h2,{id:"equality-operator-",children:["Equality Operator (",(0,t.jsx)(n.code,{children:"=="}),")"]}),"\n",(0,t.jsxs)(n.p,{children:["The equality operator is used to compare the values of two variables. If the values are the same, the expression evaluates to ",(0,t.jsx)(n.code,{children:"True"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"example",children:"Example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"a = 1000\nb = 1000\n\nprint(a == b)  # Output: True\n"})}),"\n",(0,t.jsxs)(n.p,{children:["In this example, ",(0,t.jsx)(n.code,{children:"a"})," and ",(0,t.jsx)(n.code,{children:"b"})," hold the same value (",(0,t.jsx)(n.code,{children:"1000"}),"), so ",(0,t.jsx)(n.code,{children:"a == b"})," evaluates to ",(0,t.jsx)(n.code,{children:"True"}),"."]}),"\n",(0,t.jsxs)(n.h2,{id:"identity-operator-is",children:["Identity Operator (",(0,t.jsx)(n.code,{children:"is"}),")"]}),"\n",(0,t.jsxs)(n.p,{children:["The identity operator checks if two variables refer to the same object in memory. It evaluates to ",(0,t.jsx)(n.code,{children:"True"})," if both variables point to the same memory location."]}),"\n",(0,t.jsx)(n.h2,{id:"example-1",children:"Example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"a = 1000\nb = 1000\n\nprint(a is b)  # Output: False\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Here, even though ",(0,t.jsx)(n.code,{children:"a"})," and ",(0,t.jsx)(n.code,{children:"b"})," have the same value, they are two different objects in memory. Thus, ",(0,t.jsx)(n.code,{children:"a is b"})," evaluates to ",(0,t.jsx)(n.code,{children:"False"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"small-integer-caching",children:"Small Integer Caching"}),"\n",(0,t.jsx)(n.p,{children:"Python caches small integers (usually in the range of -5 to 256) to optimize memory usage. For these integers, variables with the same value may point to the same memory location."}),"\n",(0,t.jsx)(n.h2,{id:"example-2",children:"Example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"a = 200\nb = 200\n\nprint(a is b)  # Output: True\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Since ",(0,t.jsx)(n.code,{children:"200"})," falls within the cached range, ",(0,t.jsx)(n.code,{children:"a"})," and ",(0,t.jsx)(n.code,{children:"b"})," point to the same memory location, making ",(0,t.jsx)(n.code,{children:"a is b"})," evaluate to ",(0,t.jsx)(n.code,{children:"True"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"demonstrating-the-difference-with-larger-integers",children:"Demonstrating the Difference with Larger Integers"}),"\n",(0,t.jsx)(n.p,{children:"Consider the following example with larger integers outside the cached range:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"a = 1000\nb = 1000\n\nprint(a == b)  # Output: True\nprint(a is b)  # Output: False\n\nprint(f'ID of a: {id(a)}')\nprint(f'ID of b: {id(b)}')\n"})}),"\n",(0,t.jsx)(n.p,{children:"In this case:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"a == b"})," evaluates to ",(0,t.jsx)(n.code,{children:"True"})," because their values are the same."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"a is b"})," evaluates to ",(0,t.jsx)(n.code,{children:"False"})," because they are different objects in memory, as evidenced by their different IDs."]}),"\n"]}),"\n",(0,t.jsxs)(n.h2,{id:"using-is-with-immutable-types",children:["Using ",(0,t.jsx)(n.code,{children:"is"})," with Immutable Types"]}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"is"})," operator is commonly used with immutable singleton objects like ",(0,t.jsx)(n.code,{children:"None"}),". The correct way to check if a variable is ",(0,t.jsx)(n.code,{children:"None"})," is using ",(0,t.jsx)(n.code,{children:"is"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"example-3",children:"Example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'var = None\n\nif var is None:\n    print("There is no var.")\nelse:\n    print(f"The var is {var}.")\n'})}),"\n",(0,t.jsx)(n.h2,{id:"object-identity-with-custom-classes",children:"Object Identity with Custom Classes"}),"\n",(0,t.jsxs)(n.p,{children:["For user-defined objects, ",(0,t.jsx)(n.code,{children:"is"})," checks whether two variables point to the same instance."]}),"\n",(0,t.jsx)(n.h2,{id:"example-4",children:"Example:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"class Animal:\n    pass\n\ncat = Animal()\ndog = Animal()\n\nprint(cat is dog)  # Output: False\nprint(cat is cat)  # Output: True\n\nprint(f'ID of cat: {id(cat)}')\nprint(f'ID of dog: {id(dog)}')\n"})}),"\n",(0,t.jsx)(n.p,{children:"Here:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"cat is dog"})," evaluates to ",(0,t.jsx)(n.code,{children:"False"})," because they are different instances."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"cat is cat"})," evaluates to ",(0,t.jsx)(n.code,{children:"True"})," because it's the same instance."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,t.jsxs)(n.p,{children:["Understanding the distinction between equality (",(0,t.jsx)(n.code,{children:"=="}),") and identity (",(0,t.jsx)(n.code,{children:"is"}),") operators is crucial for writing accurate and efficient Python code. Use ",(0,t.jsx)(n.code,{children:"=="})," for value comparison and ",(0,t.jsx)(n.code,{children:"is"})," for checking object identity, especially with singletons like ",(0,t.jsx)(n.code,{children:"None"}),". Avoid using ",(0,t.jsx)(n.code,{children:"is"})," for value comparisons to prevent unexpected behavior, especially with integers outside Python's cached range."]}),"\n",(0,t.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsxs)(n.strong,{children:["Equality Operator (",(0,t.jsx)(n.code,{children:"=="}),")"]}),": Compares values."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsxs)(n.strong,{children:["Identity Operator (",(0,t.jsx)(n.code,{children:"is"}),")"]}),": Compares object identities (memory addresses)."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Small Integer Caching"}),": Python caches small integers, leading to ",(0,t.jsx)(n.code,{children:"is"})," returning ",(0,t.jsx)(n.code,{children:"True"})," for small values."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Best Practices"}),": Use ",(0,t.jsx)(n.code,{children:"=="})," for value comparisons and ",(0,t.jsx)(n.code,{children:"is"})," for identity checks with singletons like ",(0,t.jsx)(n.code,{children:"None"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"By following these guidelines, you can avoid common pitfalls and ensure that your Python code behaves as expected."})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>l});var s=i(6540);const t={},r=s.createContext(t);function a(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:a(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);