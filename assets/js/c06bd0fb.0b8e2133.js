"use strict";(self.webpackChunkmy_docusaurus_site=self.webpackChunkmy_docusaurus_site||[]).push([[2558],{423:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"guide/Multithreading/Threads","title":"Threads","description":"In this tutorial, we will delve into the concepts of multithreading in Python. Before we proceed, it\'s recommended to have a basic understanding of asynchronous programming, as we will be drawing comparisons between the two concepts.","source":"@site/docs/guide/13_Multithreading/01_Threads.md","sourceDirName":"guide/13_Multithreading","slug":"/guide/Multithreading/Threads","permalink":"/Python/docs/guide/Multithreading/Threads","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/guide/13_Multithreading/01_Threads.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{},"sidebar":"guideSidebar","previous":{"title":"Multi Threading","permalink":"/Python/docs/category/multi-threading"},"next":{"title":"Locks","permalink":"/Python/docs/guide/Multithreading/Locks"}}');var i=t(4848),a=t(8453);const s={},o="Threads",l={},d=[{value:"Global Interpreter Lock (GIL)",id:"global-interpreter-lock-gil",level:2},{value:"Concurrency vs. Parallelism",id:"concurrency-vs-parallelism",level:2},{value:"Concurrency",id:"concurrency",level:3},{value:"Parallelism",id:"parallelism",level:3},{value:"Threading vs. Async IO",id:"threading-vs-async-io",level:2},{value:"Getting Started with Threading",id:"getting-started-with-threading",level:2},{value:"Setting Up",id:"setting-up",level:3},{value:"Creating Threaded Functions",id:"creating-threaded-functions",level:3},{value:"Running Threads",id:"running-threads",level:3}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"threads",children:"Threads"})}),"\n",(0,i.jsx)(n.p,{children:"In this tutorial, we will delve into the concepts of multithreading in Python. Before we proceed, it's recommended to have a basic understanding of asynchronous programming, as we will be drawing comparisons between the two concepts."}),"\n",(0,i.jsx)(n.h2,{id:"global-interpreter-lock-gil",children:"Global Interpreter Lock (GIL)"}),"\n",(0,i.jsx)(n.p,{children:"The Global Interpreter Lock, often referred to as GIL, is a crucial aspect to understand when working with multithreading in Python. The GIL ensures that only one thread can hold control of the Python interpreter at any given time. This means that even though we might have multiple threads, only one thread can execute Python bytecode at a time. This helps ensure thread safety and prevents unwanted side effects that may arise from multiple threads accessing or modifying data simultaneously."}),"\n",(0,i.jsx)(n.h2,{id:"concurrency-vs-parallelism",children:"Concurrency vs. Parallelism"}),"\n",(0,i.jsx)(n.p,{children:"Before diving deeper into multithreading, let's clarify the concepts of concurrency and parallelism. Concurrency allows multiple computations to happen simultaneously, but they are not necessarily running at the exact same time. On the other hand, parallelism requires hardware support and involves executing multiple tasks simultaneously."}),"\n",(0,i.jsx)(n.h3,{id:"concurrency",children:"Concurrency"}),"\n",(0,i.jsx)(n.p,{children:"In concurrent programming, tasks may appear to be running simultaneously, but they are actually being executed one after another. This is achieved by interleaving the execution of tasks."}),"\n",(0,i.jsx)(n.h3,{id:"parallelism",children:"Parallelism"}),"\n",(0,i.jsx)(n.p,{children:"Parallelism involves executing multiple tasks simultaneously, leveraging the capabilities of multiple cores in the hardware. Tasks run truly concurrently, without interleaving."}),"\n",(0,i.jsx)(n.h2,{id:"threading-vs-async-io",children:"Threading vs. Async IO"}),"\n",(0,i.jsx)(n.p,{children:"In Python, we have two primary ways of dealing with concurrent code: threading and asynchronous I/O (async IO)."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Threading"}),": Allows you to create multiple threads, each capable of running its own code independently."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Async IO"}),": Employs a single thread to manage multiple tasks cooperatively, utilizing non-blocking I/O operations."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Async IO provides more control over task switching, whereas threading relies on the operating system for context switching."}),"\n",(0,i.jsx)(n.h2,{id:"getting-started-with-threading",children:"Getting Started with Threading"}),"\n",(0,i.jsx)(n.p,{children:"Now, let's jump into creating our first threaded program in Python."}),"\n",(0,i.jsx)(n.h3,{id:"setting-up",children:"Setting Up"}),"\n",(0,i.jsxs)(n.p,{children:["First, ensure you have the ",(0,i.jsx)(n.code,{children:"threading"})," module imported:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"import threading\nimport time\n"})}),"\n",(0,i.jsx)(n.h3,{id:"creating-threaded-functions",children:"Creating Threaded Functions"}),"\n",(0,i.jsx)(n.p,{children:"Define a function that will be executed in each thread. For example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'def process_data(name, count):\n    print(f"Starting {name}")\n    for i in range(count):\n        print(f"{name} {i+1}:")\n        time.sleep(1)\n'})}),"\n",(0,i.jsx)(n.h3,{id:"running-threads",children:"Running Threads"}),"\n",(0,i.jsx)(n.p,{children:"Create threads and start them:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'# Create threads\nthread1 = threading.Thread(target=process_data, kwargs={"name": "Thread 1", "count": 10})\nthread2 = threading.Thread(target=process_data, kwargs={"name": "Thread 2", "count": 5})\n\n# Start threads\nthread1.start()\ntime.sleep(3)  # Wait for 3 seconds before starting the second thread\nthread2.start()\n\n# Wait for threads to finish\nthread1.join()\nthread2.join()\n'})}),"\n",(0,i.jsxs)(n.p,{children:["By using threading, tasks can appear to run simultaneously, although they execute concurrently. In this tutorial, we covered the basics of multithreading in Python, including the Global Interpreter Lock, concurrency vs. parallelism, and the differences between threading and async IO. We also created a simple multithreaded program using the ",(0,i.jsx)(n.code,{children:"threading"})," module. Multithreading can be a powerful tool for speeding up programs, especially when dealing with I/O-bound tasks. However, it's essential to understand its limitations and use cases to leverage its benefits effectively. Experiment with multithreading in your projects to see its impact on performance and efficiency. Happy coding!"]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>o});var r=t(6540);const i={},a=r.createContext(i);function s(e){const n=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);