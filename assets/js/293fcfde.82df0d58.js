"use strict";(self.webpackChunkpython=self.webpackChunkpython||[]).push([[9177],{5050:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>a,default:()=>_,frontMatter:()=>i,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"python-guide/Built_in_Functions/dunder_methods/README","title":"5 Useful Dunder Methods In Python","description":"In this guide, we\'ll explore five of the most useful Dunder (double underscore) methods in Python. These methods provide powerful functionality for customizing the behavior of classes in Python.","source":"@site/docs/python-guide/08_Built_in_Functions/19_dunder_methods/README.md","sourceDirName":"python-guide/08_Built_in_Functions/19_dunder_methods","slug":"/python-guide/Built_in_Functions/dunder_methods/","permalink":"/Python/docs/python-guide/Built_in_Functions/dunder_methods/","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/python-guide/08_Built_in_Functions/19_dunder_methods/README.md","tags":[],"version":"current","frontMatter":{},"sidebar":"guideSidebar","previous":{"title":"zip()","permalink":"/Python/docs/python-guide/Built_in_Functions/zip()/"},"next":{"title":"Dataclasses","permalink":"/Python/docs/category/dataclasses"}}');var s=t(4848),o=t(8453);const i={},a="5 Useful Dunder Methods In Python",d={},l=[{value:"Dunder Method 1: __eq__",id:"dunder-method-1-__eq__",level:2},{value:"Dunder Method 2: __format__",id:"dunder-method-2-__format__",level:2},{value:"Dunder Method 3: __or__",id:"dunder-method-3-__or__",level:2},{value:"Dunder Method 4: __str__ and __repr__",id:"dunder-method-4-__str__-and-__repr__",level:2},{value:"Dunder Method 5: __getitem__",id:"dunder-method-5-__getitem__",level:2}];function u(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"5-useful-dunder-methods-in-python",children:"5 Useful Dunder Methods In Python"})}),"\n",(0,s.jsx)(n.p,{children:"In this guide, we'll explore five of the most useful Dunder (double underscore) methods in Python. These methods provide powerful functionality for customizing the behavior of classes in Python."}),"\n",(0,s.jsx)(n.h2,{id:"dunder-method-1-__eq__",children:"Dunder Method 1: __eq__"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"__eq__"})," method allows us to define custom equality comparison between objects of our class. By default, Python's comparison operator compares memory addresses. However, by defining ",(0,s.jsx)(n.code,{children:"__eq__"}),", we can compare objects based on their attributes."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'class Fruit:\n    def __init__(self, name, grams):\n        self.name = name\n        self.grams = grams\n  \n    def __eq__(self, other):\n        return self.__dict__ == other.__dict__\n\n# Example usage:\napple1 = Fruit("apple", 100)\napple2 = Fruit("apple", 100)\norange = Fruit("orange", 150)\n\nprint(apple1 == apple2)  # Output: True\nprint(apple1 == orange)  # Output: False\n'})}),"\n",(0,s.jsx)(n.h2,{id:"dunder-method-2-__format__",children:"Dunder Method 2: __format__"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"__format__"})," method allows us to define custom formatting when using the ",(0,s.jsx)(n.code,{children:"format()"})," function or f-strings. We can specify different formats for our objects."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'class Fruit:\n    def __init__(self, name, grams):\n        self.name = name\n        self.grams = grams\n  \n    def __format__(self, format_spec):\n        if format_spec == "kg":\n            return f"{self.grams / 1000:.2f} kg"\n        elif format_spec == "lbs":\n            return f"{self.grams * 0.00220462:.2f} lbs"\n        elif format_spec == "description":\n            return f"{self.name.capitalize()} weighing {self.grams} grams"\n        else:\n            raise ValueError("Unsupported format specifier")\n\n# Example usage:\napple = Fruit("apple", 2500)\nprint(f"{apple:kg}")            # Output: 2.50 kg\nprint(f"{apple:lbs}")           # Output: 5.51 lbs\nprint(f"{apple:description}")   # Output: Apple weighing 2500 grams\n'})}),"\n",(0,s.jsx)(n.h2,{id:"dunder-method-3-__or__",children:"Dunder Method 3: __or__"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"__or__"})," method allows us to define custom behavior for combining objects using the ",(0,s.jsx)(n.code,{children:"|"})," operator. This is particularly useful for creating composite objects."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'class Fruit:\n    def __init__(self, name, grams):\n        self.name = name\n        self.grams = grams\n  \n    def __or__(self, other):\n        return Fruit(self.name + \' & \' + other.name, self.grams + other.grams)\n\n# Example usage:\napple = Fruit("apple", 100)\norange = Fruit("orange", 150)\nbanana = Fruit("banana", 200)\n\ncombined = apple | orange | banana\nprint(combined.name)   # Output: apple & orange & banana\nprint(combined.grams)  # Output: 450\n'})}),"\n",(0,s.jsx)(n.h2,{id:"dunder-method-4-__str__-and-__repr__",children:"Dunder Method 4: __str__ and __repr__"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"__str__"})," and ",(0,s.jsx)(n.code,{children:"__repr__"})," methods allow us to define custom string representations for our objects. ",(0,s.jsx)(n.code,{children:"__str__"})," is meant for user-friendly output, while ",(0,s.jsx)(n.code,{children:"__repr__"})," is for developer-oriented output."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'class Fruit:\n    def __init__(self, name, grams):\n        self.name = name\n        self.grams = grams\n  \n    def __str__(self):\n        return f"{self.name} ({self.grams}g)"\n  \n    def __repr__(self):\n        return f"Fruit(name=\'{self.name}\', grams={self.grams})"\n\n# Example usage:\napple = Fruit("apple", 100)\nprint(str(apple))  # Output: apple (100g)\nprint(repr(apple)) # Output: Fruit(name=\'apple\', grams=100)\n'})}),"\n",(0,s.jsx)(n.h2,{id:"dunder-method-5-__getitem__",children:"Dunder Method 5: __getitem__"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"__getitem__"})," method allows us to make our objects subscriptable, enabling access by index or key."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'class Basket:\n    def __init__(self, fruits):\n        self.fruits = fruits\n  \n    def __getitem__(self, item):\n        return [fruit for fruit in self.fruits if fruit.name.lower() == item.lower()]\n\n# Example usage:\nfruits = [Fruit("apple", 100), Fruit("orange", 150), Fruit("banana", 200)]\nbasket = Basket(fruits)\n\nprint(basket["orange"])  # Output: [orange (150g)]\n'})}),"\n",(0,s.jsx)(n.p,{children:"These Dunder methods provide powerful customization capabilities, allowing you to tailor the behavior of your classes to suit your specific needs in Python."})]})}function _(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(u,{...e})}):u(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>a});var r=t(6540);const s={},o=r.createContext(s);function i(e){const n=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),r.createElement(o.Provider,{value:n},e.children)}}}]);