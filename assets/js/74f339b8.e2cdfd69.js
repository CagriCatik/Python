"use strict";(self.webpackChunkmy_docusaurus_site=self.webpackChunkmy_docusaurus_site||[]).push([[6485],{6010:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>r,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"python-guide/Python_Basics/Comparing_Floats","title":"Floating Point Precision in Python","description":"Floating-point arithmetic is a fundamental aspect of computational mathematics, yet it presents challenges due to the limitations of precision in representing real numbers. This tutorial critically examines these challenges within the Python programming language and provides rigorous solutions for addressing them using the isclose function from the math module.","source":"@site/docs/python-guide/01_Python_Basics/23_Comparing_Floats.md","sourceDirName":"python-guide/01_Python_Basics","slug":"/python-guide/Python_Basics/Comparing_Floats","permalink":"/Python/docs/python-guide/Python_Basics/Comparing_Floats","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/python-guide/01_Python_Basics/23_Comparing_Floats.md","tags":[],"version":"current","sidebarPosition":23,"frontMatter":{},"sidebar":"guideSidebar","previous":{"title":"Truthy and Falsy Values in Python","permalink":"/Python/docs/python-guide/Python_Basics/Truthy_and_Falsy"},"next":{"title":"Understanding Python Scopes","permalink":"/Python/docs/python-guide/Python_Basics/Scopes"}}');var s=i(4848),o=i(8453);const r={},a="Floating Point Precision in Python",l={},c=[{value:"Problem Overview",id:"problem-overview",level:2},{value:"Addressing Precision Issues with <code>math.isclose</code>",id:"addressing-precision-issues-with-mathisclose",level:2},{value:"Function Definition",id:"function-definition",level:3},{value:"Example of Relative Tolerance",id:"example-of-relative-tolerance",level:3},{value:"Absolute Tolerance",id:"absolute-tolerance",level:3},{value:"Combining Relative and Absolute Tolerance",id:"combining-relative-and-absolute-tolerance",level:3},{value:"Practical Example: Comparing 0.1 + 0.2 with 0.3",id:"practical-example-comparing-01--02-with-03",level:2},{value:"Conclusion",id:"conclusion",level:2}];function h(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"floating-point-precision-in-python",children:"Floating Point Precision in Python"})}),"\n",(0,s.jsxs)(n.p,{children:["Floating-point arithmetic is a fundamental aspect of computational mathematics, yet it presents challenges due to the limitations of precision in representing real numbers. This tutorial critically examines these challenges within the Python programming language and provides rigorous solutions for addressing them using the ",(0,s.jsx)(n.code,{children:"isclose"})," function from the ",(0,s.jsx)(n.code,{children:"math"})," module."]}),"\n",(0,s.jsx)(n.h2,{id:"problem-overview",children:"Problem Overview"}),"\n",(0,s.jsxs)(n.p,{children:["The IEEE 754 standard for floating-point arithmetic, which Python follows, represents numbers in a binary format that can lead to precision issues. These issues arise because certain decimal numbers cannot be represented exactly as binary fractions. A common example is the sum of ",(0,s.jsx)(n.code,{children:"0.1"})," and ",(0,s.jsx)(n.code,{children:"0.2"}),", which does not exactly equal ",(0,s.jsx)(n.code,{children:"0.3"})," when computed in floating-point arithmetic:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"result = 0.1 + 0.2 == 0.3  # This may return False\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In the example above, the expression ",(0,s.jsx)(n.code,{children:"0.1 + 0.2"})," results in a value slightly different from ",(0,s.jsx)(n.code,{children:"0.3"})," due to the precision limitations of floating-point representation. Consequently, direct comparisons between floating-point numbers can lead to unexpected results, necessitating alternative approaches for accurate equality checks."]}),"\n",(0,s.jsxs)(n.h2,{id:"addressing-precision-issues-with-mathisclose",children:["Addressing Precision Issues with ",(0,s.jsx)(n.code,{children:"math.isclose"})]}),"\n",(0,s.jsxs)(n.p,{children:["The Python ",(0,s.jsx)(n.code,{children:"math"})," module provides a function, ",(0,s.jsx)(n.code,{children:"isclose"}),", which is designed to compare floating-point numbers with a specified level of tolerance. This function offers a robust method for determining whether two floating-point numbers are sufficiently close to each other, thereby mitigating the precision issues inherent in floating-point arithmetic."]}),"\n",(0,s.jsx)(n.h3,{id:"function-definition",children:"Function Definition"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"import math\n\nresult = math.isclose(a, b, *, rel_tol=1e-09, abs_tol=0.0)\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"isclose"})," function compares two numbers ",(0,s.jsx)(n.code,{children:"a"})," and ",(0,s.jsx)(n.code,{children:"b"})," using either relative tolerance (",(0,s.jsx)(n.code,{children:"rel_tol"}),"), absolute tolerance (",(0,s.jsx)(n.code,{children:"abs_tol"}),"), or a combination of both. It returns ",(0,s.jsx)(n.code,{children:"True"}),' if the numbers are considered "close" under the provided tolerances.']}),"\n",(0,s.jsx)(n.h3,{id:"example-of-relative-tolerance",children:"Example of Relative Tolerance"}),"\n",(0,s.jsx)(n.p,{children:"Relative tolerance specifies how much larger one number can be compared to another relative to their sizes. It is particularly useful when comparing numbers that are not close to zero:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"import math\n\n# Define two float values\na = 0.999\nb = 1.0\n\n# Check if the numbers are close with a relative tolerance of 0.01\nresult = math.isclose(a, b, rel_tol=0.01)\n\nprint(result)  # This will print True\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In this example, the numbers ",(0,s.jsx)(n.code,{children:"a"})," and ",(0,s.jsx)(n.code,{children:"b"})," are compared with a relative tolerance of ",(0,s.jsx)(n.code,{children:"0.01"}),", meaning that ",(0,s.jsx)(n.code,{children:"a"})," and ",(0,s.jsx)(n.code,{children:"b"})," are considered close if the difference between them is within 1% of ",(0,s.jsx)(n.code,{children:"b"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"absolute-tolerance",children:"Absolute Tolerance"}),"\n",(0,s.jsx)(n.p,{children:"Absolute tolerance is useful when comparing numbers close to zero or when a fixed margin of difference is acceptable. It defines a threshold within which two numbers are considered equal regardless of their relative difference:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"import math\n\n# Using absolute tolerance\na = 0.00001\nb = 0.00002\n\nresult = math.isclose(a, b, abs_tol=0.0001)\n\nprint(result)  # This will print True\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Here, ",(0,s.jsx)(n.code,{children:"a"})," and ",(0,s.jsx)(n.code,{children:"b"})," are considered close because their absolute difference is within ",(0,s.jsx)(n.code,{children:"0.0001"}),", which is specified by the ",(0,s.jsx)(n.code,{children:"abs_tol"})," parameter."]}),"\n",(0,s.jsx)(n.h3,{id:"combining-relative-and-absolute-tolerance",children:"Combining Relative and Absolute Tolerance"}),"\n",(0,s.jsxs)(n.p,{children:["For scenarios requiring both a flexible relative comparison and a fixed margin, ",(0,s.jsx)(n.code,{children:"isclose"})," can be used with both relative and absolute tolerance parameters:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"import math\n\n# Using both absolute and relative tolerance\na = 0.00001\nb = 0.00002\n\nresult = math.isclose(a, b, rel_tol=0.01, abs_tol=0.0001)\n\nprint(result)  # This will print True\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In this case, the comparison ensures that ",(0,s.jsx)(n.code,{children:"a"})," and ",(0,s.jsx)(n.code,{children:"b"})," are close either within a 1% range of each other or within an absolute difference of ",(0,s.jsx)(n.code,{children:"0.0001"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"practical-example-comparing-01--02-with-03",children:"Practical Example: Comparing 0.1 + 0.2 with 0.3"}),"\n",(0,s.jsxs)(n.p,{children:["Revisiting the earlier problem, let's apply ",(0,s.jsx)(n.code,{children:"isclose"})," to determine whether the sum of ",(0,s.jsx)(n.code,{children:"0.1"})," and ",(0,s.jsx)(n.code,{children:"0.2"})," is effectively equal to ",(0,s.jsx)(n.code,{children:"0.3"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"import math\n\n# Calculate the sum\nresult = 0.1 + 0.2\n\n# Check if the result is close to 0.3 with a 0.1% tolerance\nis_equal = math.isclose(result, 0.3, rel_tol=0.001)\n\nprint(is_equal)  # This will print True\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In this scenario, the use of ",(0,s.jsx)(n.code,{children:"math.isclose"})," with a relative tolerance of ",(0,s.jsx)(n.code,{children:"0.001"})," allows the comparison to correctly identify that the sum ",(0,s.jsx)(n.code,{children:"0.1 + 0.2"})," is close enough to ",(0,s.jsx)(n.code,{children:"0.3"})," to be considered equal, within the specified tolerance."]}),"\n",(0,s.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,s.jsxs)(n.p,{children:["Floating-point arithmetic poses significant challenges due to its inherent precision limitations, making direct comparison of floating-point numbers unreliable. The ",(0,s.jsx)(n.code,{children:"math.isclose"})," function in Python offers a scientifically rigorous method for performing these comparisons by allowing developers to specify both relative and absolute tolerances. By carefully selecting these tolerances based on the specific requirements of your application, it is possible to perform reliable and accurate floating-point comparisons, thereby mitigating the risks associated with floating-point precision errors in Python."]}),"\n",(0,s.jsx)(n.p,{children:"This approach should be employed whenever precision issues are expected, particularly in critical applications where numerical accuracy is paramount."})]})}function d(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>r,x:()=>a});var t=i(6540);const s={},o=t.createContext(s);function r(e){const n=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);